>if the type validation controls on the back-end server were not securely coded, an attacker can utilize multiple techniques to bypass them and reach PHP file uploads.

There are generally two common forms of validating a file extension on the back-end:

1. Testing against a `blacklist` of types
2. Testing against a `whitelist` of types

validation may also check the `file type` or the `file content` for type matching.

`testing the file extension against a blacklist of extension` == weak testing

```php
$fileName = basename($_FILES["uploadFile"]["name"]);
$extension = pathinfo($fileName, PATHINFO_EXTENSION);
$blacklist = array('php', 'php7', 'phps');

if (in_array($extension, $blacklist)) {
    echo "File type not allowed";
    die();
}
```

The comparison above is also case-sensitive, and is only considering lowercase extensions.

Windows Servers, file names are case insensitive>  `pHp`, which may bypass the blacklist > execute as a PHP script.


## Fuzzing Extensions

1- first step is to fuzz the upload functionality with a list of potential extensions and see which of them return the previous error message.

---
list:
`PayloadsAllTheThings` provides lists of extensions for [PHP](https://github.com/swisskyrepo/PayloadsAllTheThings/blob/master/Upload%20Insecure%20Files/Extension%20PHP/extensions.lst) and [.NET](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/Upload%20Insecure%20Files/Extension%20ASP)

Discovery/Web-Content/web-extensions.txt

---

>`.phtml` extension, which PHP web servers often allow for code execution rights.


![[suxrqei3.png]]
un-tick the `URL Encoding` option to avoid encoding the (`.`) before the file extension
`Upload Insecure Files/Extension PHP/extensions.lst`
![[de1t89mr.png]]

```bash
http://SERVER_IP:PORT/profile_images/Untitled.php3
```

ÿØÿà

Payload:	.php%00.gif
.php\x00.gif
.php%00.png
.php\x00.png
.php%00.jpg
.php\x00.jpg
