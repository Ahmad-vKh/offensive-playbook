
The most basic type of file upload vulnerability:
web application `does not have any form of validation filters` on the uploaded files, allowing the upload of any file type by default.
then by just visiting the uploaded script,


## Identifying Web Framework

1- upload a malicious script to test whether we can upload any file type to the back-end server

2- test `Web Shell` script and a `Reverse Shell` script.

A Web Shell:
provides us with an easy method to interact with the back-end server by accepting shell commands and printing their output back to us within the web browser.

>the first step would be to identify what language runs the web application.
A web shell has to be written in the same programming language that runs the web server

PROBLEM:
we can know by URL BUT >  sometimes `Web Routes` are used to map URLs to web pages
web page extension may not be shown.

file upload exploitation would also be different, as our uploaded files may not be directly routable or accessible

solution:
visit <> `/index.ext` > swap out `ext` with various common web extensions, like `php`, `asp`, `aspx`, among others, to see whether any of them exist.
```bash
FUZZING <> Discovery/Web-Content/web-extensions.txt
```
```bash
ffuf -u http://SERVER_IP:PORT/index.FUZZ -w /usr/share/seclists/Discovery/Web-Content/web-extensions.txt -fc '---' 

```

>`as the `index` page is usually hidden by default`


if > visiting `http://SERVER_IP:PORT/**index**.php`, we **would** get the same page == VALID

#### This method may not always be accurate, as the web application may not utilize index pages or may utilize more than one web extension.

using the [Wappalyzer](https://www.wappalyzer.com) extension


```php
<?php echo "Hello HTB";?>      ---     test.php
```

```php
<?php system("hostname"); ?>
```

Try to upload a PHP script that executes the (hostname) command on the back-end server, and submit the first word of it as the answer.
 You may use the 'system()' PHP function to execute system commands




