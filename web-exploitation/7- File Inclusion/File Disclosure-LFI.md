## Basic LFI
```
http://<SERVER_IP>:<PORT>/
```

```php
http://<SERVER_IP>:<PORT>/index.php?language=es.php
```
`language` parameter
if the web application is indeed pulling a file that is now being included in the page, we may be able to change the file being pulled to read the content of a different local file

Two common readable files that are available on most back-end servers are `/etc/passwd` on Linux and `C:\Windows\boot.ini` on Windows. So, let's change the parameter from `es` to `/etc/passwd`
http://<SERVER_IP>:`<PORT>`/index.php?language=/etc/passwd
vulnerable

## Path Traversal
This would work if the whole input was used within the `include()` function without any additions, like the following example:
```php
include($_GET['language']);
```

the `language` parameter may be used for the filename, and may be added after a directory, as follows:
```php
include("./languages/" . $_GET['language']);
```

>if we attempt to read `/etc/passwd`, then the path passed to `include()` would be (`./languages//etc/passwd`), and as this file does not exist, we will not be able to read anything

`../` before our file name, which refers to the parent directory. For example, if the full path of the languages directory is `/var/www/html/languages/`
trick to go back several directories until we reach the root path (i.e. `/`)
(`../../../../etc/passwd`)

http://<SERVER_IP>:`<PORT>`/index.php?language=../../../../etc/passwd

>if we were at the root path (`/`) and used `../` then we would still remain in the root path. So, if we were not sure of the directory the web application is in, we can add `../` many times, and it should not break the path (even if we do it a hundred times!).



>It can always be useful to be efficient and not add unnecessary `../` several times, especially if we were writing a report or writing an exploit. So, always try to find the minimum number of `../` that works and use it. You may also be able to calculate how many directories you are away from the root path and use that many. For example, with `/var/www/html/` we are `3` directories away from the root path, so we can use `../` 3 times (i.e. `../../../`).



## Filename Prefix
```php
include("lang_" . $_GET['language']);
```

In this case, if we try to traverse the directory with `../../../etc/passwd`, the final string would be `lang_../../../etc/passwd`, which is invalid

>http://<SERVER_IP>:`<PORT>`/index.php?language=/../../../etc/passwd



## Appended Extensions
Another very common example is when an extension is appended to the `language` parameter, as follows:
```php
include($_GET['language'] . ".php");
```
This is quite common
if we try to read `/etc/passwd`, then the file included would be `/etc/passwd.php`, which does not exist


>**Exercise:** Try to read any php file (e.g. index.php) through LFI, and see whether you would get its source code or if the file gets rendered as HTML instead.


## Second-Order Attacks
Exploiting LFI vulnerabilities using second-order attacks is similar to what we have discussed in this section. The only variance is that we need to spot a function that pulls a file based on a value we indirectly control and then try to control that value to exploit the vulnerability.




**Note:** All techniques mentioned in this section should work with any LFI vulnerability, regardless of the back-end development language or framework.

